# 训练方法

随机梯度下降：随机采样

关注的不是收敛快不快，而是收敛到哪一个点；牛顿法可能不平坦
## 训练过程

对于每一个小批量，我们会进行以下步骤:

- 通过调用net(X)生成预测并计算损失l（前向传播）。
- 通过进行反向传播来计算梯度。
- 通过调用优化器来更新模型参数。


### 训练框架
`epoch`: 训练轮次
`iter` 训练小批量

nn模块定义了大量的神经网络层和常见损失函数。
```python
num_epochs = 3
for epoch in range(num_epochs):
    for X, y in data_iter:
        l = loss(net(X) ,y)
        trainer.zero_grad() # 清除梯度，防止累计
        l.backward() # 自动计算梯度
        trainer.step() # 优化算法
    l = loss(net(features), labels)
    print(f'epoch {epoch + 1}, loss {l:f}')
```

### 初始化
可以使用固定的初始值，但是不能为0

!!! tip "如果我们将权重初始化为零，会发生什么。算法仍然有效吗？"

    如果将权重初始化为零，那么每个神经元的输出都是相同的，这意味着每个神经元学习到的参数也是相同的。因此，每个神经元都会更新相同的参数，最终导致所有神经元学习到相同的特征。因此，权重初始化为零会使算法失效。这样就失去了神经网络的优势，即可以学习到不同特征的能力。
    
    逻辑回归和神经网络有不同的权重初始化方法。对于逻辑回归，可以将权重初始化为零，因为这是一个线性模型，梯度下降算法仍然可以更新它们。然而，对于神经网络来说，将权重初始化为零可能会导致对称性问题，并阻止隐藏单元学习不同的特征。因此，最好使用随机或其他方法来初始化神经网络的权重。




### 学习率

尝试使用不同的学习率，观察损失函数值下降的快慢。

学习率过大前期损失值下降快，但是后面不容易收敛
学习率太小，损失函数下降慢

调学习率的一些心得
1. 选择对学习率不太敏感的算法：Adam
2. 合理的参数的初始化
  

学习率设置过大会导致梯度爆炸的问题


### 收敛判断 | epoch
- 真实训练中，凭直觉
- 先训练小批次


